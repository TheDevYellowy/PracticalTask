package com.thedevyellowy.practicalTask.util;

import com.thedevyellowy.practicalTask.PracticalTask;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.loot.LootContext;
import org.bukkit.loot.LootTable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Random;

public class HGLootTable implements LootTable {
  /**
   * Returns a mutable list of loot generated by this LootTable.
   *
   * @param random  the random instance to use to generate loot
   * @param context context within to populate loot
   * @return a list of ItemStacks
   */
  @Override
  public @NotNull Collection<ItemStack> populateLoot(@Nullable Random random, @NotNull LootContext context) {
    return List.of();
  }

  /**
   * Attempt to fill an inventory with this LootTable's loot.
   *
   * @param inventory the inventory to fill
   * @param random    the random instance to use to generate loot
   * @param context   context within to populate loot
   */
  @Override
  public void fillInventory(@NotNull Inventory inventory, @Nullable Random random, @NotNull LootContext context) {
    ExternalLootTable lootTable = ExternalLootTable.load();
    if(lootTable == null) {
      PracticalTask.Logger.error("There is no loot table to load at /plugins/Minigames/hungergames_loottable.json");
      return;
    }

    for (ExternalLootTable.pools pool : lootTable.pools) {
      int amount;
      if(pool.rolls.max > 0) {
        amount = random.nextInt(pool.rolls.min, pool.rolls.max);
      } else amount = pool.rolls.min;

      for (int i = 0; i < amount; i++) {
        int ent = random.nextInt(pool.entries.length);
        ExternalLootTable.entries entry = pool.entries[ent];

        PracticalTask.Logger.info(entry.name);
        ItemStack item = ItemStack.of(Material.getMaterial(entry.name.split(":")[1].toUpperCase()));
        Arrays.stream(entry.functions).forEach(function -> {
          if(function.function.equals("minecraft:enchant_with_levels")) {
            int levels = function.levels;
            for (ExternalLootTable.conditions condition : function.conditions) {
              double chance = random.nextDouble(1);
              if(chance <= condition.chance) {
                item.enchantWithLevels(levels, false, random);
              }
            }
          } else if(function.function.equals("minecraft:set_count")) {
            ExternalLootTable.count count = function.count;
            item.setAmount(random.nextInt(count.min, count.max));
          }
        });
        int slot = random.nextInt(0, inventory.getSize());
        while(!canPlace(inventory, slot, item)) {
          slot = random.nextInt(0, inventory.getSize());
        }

        inventory.setItem(slot, item);
      }
    }
  }

  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
   */
  @Override
  public @NotNull NamespacedKey getKey() {
    return new NamespacedKey(PracticalTask.getPlugin(PracticalTask.class), "hgloot");
  }

  public boolean canPlace(Inventory inventory, int slot, ItemStack item) {
    ItemStack itemInSlot = inventory.getItem(slot);
    if(itemInSlot == null) return true;
    if(!itemInSlot.getItemMeta().equals(item.getItemMeta())) return false;
    if((itemInSlot.getAmount() + item.getAmount()) > item.getMaxStackSize()) return false;

    return true;
  }
}
